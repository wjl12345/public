var min = Math.min;
var max = Math.max;
var abs = Math.abs;
var hypot = Math.hypot;
module.exports = {
  getDefaultCfg: function getDefaultCfg() {
    return {
      brushStyle: {
        fill: '#EEF6FF',
        fillOpacity: 0.4,
        stroke: '#DDEEFE',
        lineWidth: 1
      },
      onSelect: function onSelect() {},
      onDeselect: function onDeselect() {},
      selectedState: 'selected'
    };
  },
  getEvents: function getEvents() {
    return {
      mousedown: 'onMouseDown',
      mousemove: 'onMouseMove',
      mouseup: 'onMouseUp',
      'canvas:click': 'clearStates'
    };
  },
  onMouseDown: function onMouseDown(e) {
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates();
    }

    var brush = this.brush;

    if (!brush) {
      brush = this._createBrush();
    }

    this.originPoint = {
      x: e.canvasX,
      y: e.canvasY
    };
    brush.attr({
      width: 0,
      height: 0
    });
    brush.show();
    this.dragging = true;
  },
  onMouseMove: function onMouseMove(e) {
    var originPoint = this.originPoint;

    if (!this.dragging || hypot(originPoint.x - e.canvasX, originPoint.y - e.canvasY) < 10) {
      return;
    }

    this._updateBrush(e);

    this.graph.paint();
  },
  onMouseUp: function onMouseUp(e) {
    var graph = this.graph;
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false);
    this.brush.hide();

    this._getSelectedNodes(e);

    this.dragging = false;
    this.graph.paint();
    graph.setAutoPaint(autoPaint);
  },
  clearStates: function clearStates() {
    var graph = this.graph;
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false);
    var selectedState = this.selectedState;
    var shouldUpdate = this.shouldUpdate;
    var selectedNodes = [];
    var result = this.selectedNodes.filter(function (node) {
      if (shouldUpdate(node, 'deselect')) {
        graph.setItemState(node, selectedState, false);
        return true;
      }

      selectedNodes.push(node);
      return false;
    });
    this.onDeselect && this.onDeselect(result);
    this.selectedNodes = selectedNodes;
    graph.paint();
    graph.setAutoPaint(autoPaint);
  },
  _getSelectedNodes: function _getSelectedNodes(e) {
    var graph = this.graph;
    var state = this.selectedState;
    var originPoint = this.originPoint;
    var p1 = {
      x: e.x,
      y: e.y
    };
    var p2 = graph.getPointByCanvas(originPoint.x, originPoint.y);
    var left = min(p1.x, p2.x);
    var right = max(p1.x, p2.x);
    var top = min(p1.y, p2.y);
    var bottom = max(p1.y, p2.y);
    var selectedNodes = [];
    var shouldUpdate = this.shouldUpdate;
    graph.getNodes().forEach(function (node) {
      var bbox = node.getBBox();

      if (bbox.centerX >= left && bbox.centerX <= right && bbox.centerY >= top && bbox.centerY <= bottom) {
        if (shouldUpdate(node, 'select')) {
          selectedNodes.push(node);
          graph.setItemState(node, state, true);
        }
      }
    });
    this.selectedNodes = selectedNodes;
    this.onSelect && this.onSelect(selectedNodes);
  },
  _createBrush: function _createBrush() {
    var self = this;
    var brush = self.graph.get('canvas').addShape('rect', {
      attrs: self.brushStyle,
      capture: false
    });
    this.brush = brush;
    return brush;
  },
  _updateBrush: function _updateBrush(e) {
    var originPoint = this.originPoint;
    this.brush.attr({
      width: abs(e.canvasX - originPoint.x),
      height: abs(e.canvasY - originPoint.y),
      x: min(e.canvasX, originPoint.x),
      y: min(e.canvasY, originPoint.y)
    });
  }
};